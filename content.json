{"pages":[{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Markdown语法","text":"markdown语法 [TOC] 标题:#，##... 水平分割线:***或者--- 数学公式 $lim_{x \\to \\infty} \\ exp(-x)=0$ $lim_{x \\to \\infty} \\ exp(-x)=0$ 下标subscript H~2~O H~2~O 上标superscript y^2^=4 y^2^=4 高亮 ==highlight== ==highlight== 块引用 这个是块引用 hhhheeelllo &gt;hhhheeelllo 列表 unordered list hello hi hey ordered list red blue green 任务列表 一个任务列表 学习 洗澡 睡觉 代码块 12def multiply(x, y): return x*y 表格 姓名 性别 爱因斯坦 男 注释 你可以这样添加注释，像这样^注释 强调 使用**强调内容**或者__强调内容__ 这是星号强调–推荐 这是下划线强调 链接 这是一条链接 URLS http://www.baidu.comheeeeee 删除线 删除这些文本 ~~删除文本~~ Emoji ​:happy: :happy: Emphasis wow haha *wow haha* Table of Contents [toc]","link":"/2016-01-10-markdown-rule/"},{"title":"C和指针中的一处错误","text":"C和指针的一处错误","link":"/2016-01-28-candpointer_error/"},{"title":"Java IO","text":"java IO流IO也写作I/O，可理解为In与Out，即输入与输出。IO体系的基本功能就是：读和写。 IO流 读写设备上的数据，硬盘文件，内存，键盘，网络…… 根据数据走向，分为输入流与输出流根据数据类型，分为字节流与字符流 字节流字节流可以处理所有类型的数据，如MP3，图片，文字，视频等。读到一个字节就返回一个字节。在java中对应的类以Stream结尾。如：InputStream、 OutputStream 字符流字符流仅能处理纯文本数据，如txt文本等。在读取时，读到一个或多个字节，先查找制定的编码表，然后将查到的字符返回。在java中对应的类以Reader、Writer结尾。 转换InputStreamReader 是字节流通向字符流的桥梁OutputStreamWriter 是字符流通向字节流的桥梁 带缓冲区的流BufferedInputStream BufferedOutputStream 字节流带缓冲区 BufferedReader BufferedWriter 字符流带缓冲区 (BufferedReader带readLine()方法，BufferedWriter带newLine()与flush()方法)","link":"/2016-02-05-java-io/"},{"title":"OpenSSL心脏滴血漏洞","text":"OpenSSL心脏滴血漏洞 CVE-2014-0160心脏出血漏洞（英语：Heartbleed bug），也简称为心血漏洞，是一个出现在加密程序库OpenSSL的程序错误，首次于2014年4月披露。该程序库广泛用于实现互联网的传输层安全（TLS）协议。只要使用的是存在缺陷的OpenSSL实例，无论是服务器还是客户端，都可能因此而受到攻击。此问题的原因是在实现TLS的心跳扩展时没有对输入进行适当验证（缺少边界检查），因此漏洞的名称来源于“心跳”（heartbeat）。该程序错误属于缓冲区过读，即可以读取的数据比应该允许读取的还多。 漏洞原因：OpenSSL 在实现 TLS/DTLS 心跳扩展协议 (RFC6520) 时没有检查客户端载荷与载荷长度值是否匹配 TLS/SSL原理简介SSL/TLS协议的基本思路是采用公钥加密法，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 SSL/TLS协议的基本过程握手阶段 客户端向服务端索要并验证公钥。 双方协商生成“对话密钥”。 双方采用“对话密钥”进行通信。 握手阶段详细过程1.客户端发送请求（ClientHello）：客户端给出协议版本号、一个客户端生成的随机数，以及客户端支持的加密方式 协议版本 客户端随机数（Client random） 加密方式 压缩方法 2.服务器回应（ServerHello）：服务端确认双方的加密方式，并给出数字证书、以及一个服务端生成的随机数 确认协议版本 服务端随机数（Server random） 加密方式 服务器证书 3.客户端回应：客户端确认数字证书有效，然后生成一个随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数发给服务端，利用三个随机数和约定的加密方法生成“对话密钥” 一个随机数。用公钥加密（Premaster secret） 编码改变通知 客户端握手结束通知 4.服务器的最后回应：根据私钥获取客户端发来的随机数，按照约定的加密方法用三个随机数生成”对话密钥“ 编码改变通知 服务器握手结束通知 心脏滴血漏洞原理分析典型的 SSL/TLS 会话建立过程是，客户端和服务端进行握手，协商加密算法，参数；成功后，进行加密通信，此时也开始心跳包的发送和接收，用于判断对方是否在线。问题出在服务端对心跳包的处理逻辑上。心跳包的机制：当接受者收到心跳包A时，要回复给发送者一个心跳包B，B的载荷要与A的相同。发送者收到B，将之与A比对，相同，则连接有效；不同，则重传该心跳包。心跳请求报文格式，消息类型1字节，载荷长度2字节，载荷（序号+随机值）18字节，padding12345* - Message Type, 1 byte* - Payload Length, 2 bytes (unsigned int)* - Payload, the sequence number (2 bytes uint)* - Payload, random bytes (16 bytes uint)* - Padding 该问题出在对心跳请求报文的处理上，由于心跳请求报文是客户端发送的，所以是可以进行伪造的。处理心跳请求报文：先将指针p指向心跳请求报文首地址：12345678int tls1_process_heartbeat(SSL *s)&#123; unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0], *pl; unsigned short hbtype; unsigned int payload; unsigned int padding = 16; /* Use minimum padding */ ......&#125; 取出心跳包类型、客户端设置的载荷长度，并用pl指向载荷首地址：123hbtype = *p++;n2s(p, payload);pl = p; 判断如果心跳包类型是请求，就用从心跳请求报文中获取的载荷长度来计算分配空间，准备填充返回消息：123456789101112if (hbtype == TLS1_HB_REQUEST) &#123; unsigned char *buffer, *bp; int r; /* * Allocate memory for the response, size is 1 bytes message type, * plus 2 bytes payload length, plus payload, plus padding */ buffer = OPENSSL_malloc(1 + 2 + payload + padding); if (buffer == NULL) return -1; bp = buffer; 构造返回报文：12345678910/* Enter response type, length and copy payload */*bp++ = TLS1_HB_RESPONSE;s2n(payload, bp);memcpy(bp, pl, payload);bp += payload;/* Random padding */if (RAND_bytes(bp, padding) &lt;= 0) &#123; OPENSSL_free(buffer); return -1;&#125; 在构造返回报文时，memcpy(bp, pl, payload);，使用的长度是客户端发送过来请求报文的载荷长度，服务端并没有进行检查。如果构造一个恶意的请求包，设定的长度为payload，实际发送的载荷比payload短或者不发送载荷，这个memcpy将把服务端内存中的其他数据复制到buff中，并返回给客户端。极限情况下，伪造包的payload可以设定的载荷长度为65535（64KB），但不携带任何载荷，服务端将会以每次64KB的速度泄露。","link":"/2016-03-15-ssl-heart/"},{"title":"linux下网络套接字编程","text":"基本的套接字编程 IPv4套接字-网际套接字地址结构123456789101112131415#include &lt;netinet/in.h&gt;struct in_addr &#123; in_addr_t s_addr;&#125;;struct sockaddr_in &#123; uint8_t sin_len; sa_family_t sin_family; in_port_t sin_port; struct in_addr sin_addr; char sin_zero[8];&#125;; 通用套接字地址结构1234567#include &lt;sys/socket.h&gt; struct sockaddr &#123; uint8_t sa_len; sa_family_t sa_family; char sa_data[14]; &#125;; 字节序低序字节存储在起始地址，小端(little-endian) 高序字节存储在起始地址，大端(big-endian) host byte order 主机字节序network byte order 网络字节序(大端序) 1234567#include &lt;netinet/in.h&gt;uint16_t htons(uint16_t host16bitvalue);uint32_t htonl(uint32_t host32bitvalue);uint16_t ntohs(uint16_t net16bitvalue);uint32_t ntohl(uint32_t net32bitvalue); 字节操纵函数12345#include &lt;strings.h&gt;void bzero(void *dest, size_t nbytes);void bcopy(const void *src, void *dest, size_t nbytes);int bcmp(const void *ptr1, const void *ptr2, size_t nbytes);//相等返回0，否则非0 点分十进制串与32位网络字节序二进制值的转换1234567#include &lt;arpa/inet.h&gt;int inet_aton(const char *strptr, struct in_addr *addrptr);//若字符串有效则为1，否则为0in_addr_t inet_addr(const char *strptr); //若字符串有效则为32位二进制网络字节序的IPv4地址，否则为INADDR_NONEchar *inet_ntoa(struct in_addr inaddr); //返回一个指向点分十进制数串的指针 点分十进制 ——–inet_aton,inet_addr——–&gt; in_addr{}in_addr{} ————-inet_ntoa————-&gt; 点分十进制 套接字编程 123456789#include &lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr *servaddr, addrlen_t addrlen); //成功为0，出错-1int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen); //成功为0，出错-1int listen(int sockfd, int backlog); //成功为0，出错-1int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen); //成功为0，出错-1 实例server.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include \"unp.h\"int main(int argc, char *argv[])&#123; int listen_fd, connect_fd; struct sockaddr_in server_addr; struct sockaddr_in client_addr; int sin_size, port; char hello[] = \"Hello ! Are you OK ? \\n\"; if (argc != 2) &#123; fprintf(stderr, \"usage: %s port \\a\\n\", argv[0]); exit(1); &#125; if ((port = atoi(argv[1])) &lt; 0) &#123; fprintf(stderr, \"usage: %s port \", argv[0]); exit(1); &#125; /*服务器建立socket 监听端口*/ if ((listen_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) &#123; fprintf(stderr, \"socket establish error : %s \\n\", strerror(errno)); exit(1); &#125; /*填充服务器sockaddr_in*/ bzero(&amp;server_addr, sizeof(struct sockaddr_in)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = htonl(INADDR_ANY); server_addr.sin_port = htons(port); /*邦定描述符*/ if (bind(listen_fd, (struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr)) == -1) &#123; fprintf(stderr, \"bind error: %s \\n\", strerror(errno)); exit(1); &#125; /*监听描述符*/ if (listen(listen_fd, 5) == -1) &#123; fprintf(stderr, \"listen error: %s \\n\", strerror(errno)); exit(1); &#125; while(1) &#123; sin_size = sizeof(struct sockaddr_in); /*服务程序阻塞直到客户端连接*/ if ((connect_fd = accept(listen_fd, (struct sockaddr *)&amp;client_addr, &amp;sin_size)) == -1) &#123; fprintf(stderr, \"accept error: %s \\n\", strerror(errno)); exit(1); &#125; fprintf(stdout, \"server get connection from %s \\n\", inet_ntoa(client_addr.sin_addr)); if (write(connect_fd, hello, strlen(hello)) == -1) &#123; fprintf(stderr, \"write error : %s \\n\", strerror(errno)); exit(1); &#125; close(connect_fd); &#125; close(listen_fd); exit(0);&#125; client.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include \"unp.h\"int main(int argc, char *argv[]) &#123; int sockfd; char buffer[1024]; struct sockaddr_in server_addr; struct hostent *host; int port, nbytes; if (argc != 3) &#123; fprintf(stderr, \"usage: %s hostname port \\n\", argv[0]); exit(1); &#125; if ((host=gethostbyname(argv[1])) == NULL) &#123; fprintf(stderr, \"gethostname error \\n\"); exit(1); &#125; if((port = atoi(argv[2])) &lt; 0) &#123; fprintf(stderr, \"usage: %s hostname port \\n\", argv[0]); exit(1); &#125; /*客户程序开始建立sockfd描述符*/ if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) &#123; fprintf(stderr, \"socket error: %s \\n\", strerror(errno)); exit(1); &#125; /*客户程序填充服务端资料*/ bzero(&amp;server_addr, sizeof(struct sockaddr_in)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); server_addr.sin_addr = *((struct in_addr *)host-&gt;h_addr); /*客户端发起请求*/ if (connect(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr)) == -1) &#123; fprintf(stderr, \"connect error: %s \\n\", strerror(errno)); exit(1); &#125; /*连接成功*/ if ((nbytes = read(sockfd, buffer, 1024)) == -1) &#123; fprintf(stderr, \"read error %s \\n\", strerror(errno)); exit(1); &#125; buffer[nbytes] = '\\0'; printf(\"Received : %s \\n\", buffer); /*结束通讯*/ close(sockfd); exit(0);&#125; unp.h 12345678910111213141516171819202122232425262728293031#ifndef _UNP_H#define _UNP_H#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/time.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;netdb.h&gt;#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;strings.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/uio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/un.h&gt;#endif","link":"/2016-02-10-unix-socket/"},{"title":"python文件操作","text":"python文件批量重命名操作python批量更改文件名123456789101112131415161718192021222324import osdef change_name(path): global count; if not os.path.isfile(path) and not os.path.isdir(path): return False; if os.path.isfile(path): filepath = os.path.split(path) filename = os.path.splitext(filepath[-1]) file_ext = filename[-1] if file_ext == '.txt': os.rename(path, filepath[0]+'/'+'ex_'+str(count)+file_ext) count += 1 elif os.path.isdir(path): for x in os.listdir(path): change_name(os.path.join(path, x))count = 1file_dir = 'C:/Users/lansheng/Desktop/py'change_name(file_dir) 用md5查找文件夹下相同文件并删除1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import osimport hashlibfrom time import clock as nowdef getmd5(filename): file_txt = open(filename, 'rb').read() md5 = hashlib.md5() md5.update(file_txt) return md5.hexdigest()path = '.'all_md5 = []total_file = 0delete_file = 0def del_dump(path): global total_file global delete_file for parent, dirnames, filenames in os.walk(path): for filename in filenames: total_file += 1 real_path = os.path.join(parent, filename) #print real_path filemd5 = getmd5(real_path) if filemd5 in all_md5: delete_file += 1 #do delete os.remove(real_path) print 'remove:',real_path else: all_md5.append(filemd5)def del_emptydir(path): if os.path.isdir(path): for p in os.listdir(path): d = os.path.join(path, p) if(os.path.isdir(d) == True): del_emptydir(d) #recursive if not os.listdir(path): os.rmdir(path) print 'remove dir:', path start = now()del_dump(path)#del_emptydir(path)end = now()time_last = end - startprint 'total file: ', total_fileprint 'delete file: ', delete_fileprint 'cost time: ', time_last, 's'","link":"/2016-04-04-python-fileop/"},{"title":"dijkstra算法","text":"dijkstra算法浅析给定带权有向网络G=(V,E,W),每条边e=&lt;i,j&gt;的权w(e)为非负实数，表示从i到j的距离。源点s∈V.求从s出发到达其他节点的最短路径. x∈S &lt;=&gt;x∈V且从s到x的最短路径已经找到初始：S={s}, S=V时算法结束从s到u相对于S的最短路径：从s到u且仅经过S中顶点的最短路径dist[u]:从s到u相对于S最短路径的长度short[u]:从s到u的最短路径的长度dist[u]&gt;=short[u] 输入：有向图G=(V,E,W), V={1,2,…,n}, s=1输出：从s到每个顶点的最短路径1.初始S={1}2.对于i∈V-S,计算1到i的相对于S的最短路，长度dist[i]3.选择V-S中dist值最小的j,将j加入S,修改V-S中顶点的dist值.4.继续上述过程，直到S=V为止 伪码12345678910S &lt;- &#123;s&#125; dist[s] &lt;- 0 for i ∈ V-&#123;s&#125; do dist[i] &lt;- w(s, i) //s到i没边，w(s,i)=∞ while V-S != Ø do # 从V-S取相对S的最短路径顶点j S &lt;- S∪&#123;j&#125; for i ∈ V-S do if dist[j] + w(j,i) &lt; dist[i] dist[i] &lt;- dist[j] + w(j, i) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#define VERTEXNUM 6#define INFINITY 10000 int path[VERTEXNUM];int distance[VERTEXNUM];int visited[VERTEXNUM];int graph[VERTEXNUM][VERTEXNUM] = &#123;// 0 1 2 3 4 5 0, 1, INFINITY, 4, 4, INFINITY, //0 1, 0, INFINITY, 2, INFINITY, INFINITY, //1 INFINITY, INFINITY, 0, 2, INFINITY, 1, //2 4, 2, 2, 0, 3, INFINITY, //3 4, INFINITY, INFINITY, 3, 0, 3, //4 INFINITY, INFINITY, 1, INFINITY, 3, 0 //5&#125;;void dijkstra(int source) &#123; int i, j, vertex, min_edge, edges; visited[source] = 1; for (i = 0; i &lt; VERTEXNUM; i++) &#123; distance[i] = graph[source][i]; &#125; distance[source] = 0; for (edges = 0; edges &lt; VERTEXNUM; edges++) &#123; min_edge = INFINITY; for (j = 0; j &lt; VERTEXNUM; j++) &#123; if (visited[j] == 0 &amp;&amp; min_edge &gt; distance[j]) &#123; vertex = j; min_edge = distance[j]; &#125; &#125; visited[vertex] = 1; for (j = 0; j &lt; VERTEXNUM; j++) &#123; if (visited[j] == 0 &amp;&amp; distance[vertex] + graph[vertex][j] &lt; distance[j]) &#123; distance[j] = distance[vertex] + graph[vertex][j]; path[j] = vertex; &#125; &#125; &#125;&#125;int main()&#123; dijkstra(0); for (int i = 0; i &lt; VERTEXNUM; i++) &#123; printf(\"dist[%d]=%d\\t\", i, distance[i]); &#125; printf(\"\\n\"); for (int i = 0; i &lt; VERTEXNUM; i++) &#123; printf(\"path[%d]=%d\\t\", i, path[i]); &#125; printf(\"\\n\"); return 0;&#125;","link":"/2016-05-20-dijkstra-algo/"},{"title":"kmp算法","text":"kmp算法浅析在计算机科学中，Knuth-Morris-Pratt 字符串查找算法（常简称为“KMP算法”）可在一个主文本字符串S内查找一个词W的出现位置。此算法通过运用对这个词在不匹配时本身就包含足够的信息来确定下一个匹配将在哪里开始，从而避免重新检查先前匹配的字符。 给定一个字符串txt，和一个模式串pat：txt[] = “BBC ABCDAB ABCDABCDABDE”pat[] = “ABCDABD”Output: Pattern found at index 15 1.部分匹配表前缀与后缀： “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。 举例：字符串 ABCAB前缀：A,AB,ABC,ABCA后缀：B,AB,CAB,BCAB 部分匹配值是前缀与后缀的最长共有元素的长度，上例最长共有元素为”AB”，所以字符串”ABCAB”的部分匹配值是2 字符串的部分匹配表字符串对应一个相同长度的数组，其中每个数字代表的是从字符串开始到当前位的字符子串的部分匹配值举例:“ABCDABD”“0000120” 下面来介绍如何计算模式串的部分匹配表pat “AAAA”,next[] is [0, 1, 2, 3] pat “ABCDE”,next[] is [0, 0, 0, 0, 0] pat “AAABAAA”,next[] is [0, 1, 2, 0, 1, 2, 3] 举例说明,当pat[] = “AAAA”pat[0] = “A”前缀x,后缀x最大公共元素长度0next[0] = 0 pat[0-1] = “AA”前缀A,后缀A最大公共元素长度1next[1] = 1 pat[0-2] = “AAA”前缀A,AA,后缀A,AA最大公共元素长度2next[2] = 1 pat[0-3] = “AAAA”前缀A,AA,AAA,后缀A,AA,AAA最大公共元素长度3next[3] = 3 所以字符串pat[] = “AAAA”的部分匹配表为[0, 1, 2, 3]. 2.kmp算法给定一个字符串txt，和一个模式串pat：txt[] = “BBC ABCDABEABCDABCDABDE”pat[] = “ABCDABD” 2.1 计算模式串pat的部分匹配表nextnext[] = [0, 0, 0, 0, 1, 2, 0] 2.2 字符串txt与模式串pat的第一位进行比较，如果不匹配，则将txt的后一位字符与pat第一位字符比较。“BBC ABCDABEABCDABCDABDE”“ABCDABD” “BBC ABCDABEABCDABCDABDE”“ABCDABD”… 2.3 当txt的字符与pat字符匹配时，同时后移两个字符串的字符进行比较。“BBC ABCDABEABCDABCDABDE”“ABCDABD” “BBC ABCDABEABCDABCDABDE”“ABCDABD” 2.4 当失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符前一位对应的next值“BBC ABCDABEABCDABCDABDE”“ABCDABD“ 2.5 pat移动字符的位数 = 失配字符所在位置6 - 失配字符前一位字符对应的next[5]值2 = 4,从适配字符D处往回移动4个字符，到达C，进行比较“BBC ABCDABEABCDABCDABDE”“ABCDABD” 2.6 不断循环上述步骤，直到匹配到模式串末尾，或者不匹配 3.代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;void CalcNext(char *pat, int *next) &#123; int m = strlen(pat); next[0] = 0; int len = 0; int i = 1; while (i &lt; m) &#123; if (pat[i] == pat[len]) &#123; len++; next[i++] = len; &#125; if (i &lt; m &amp;&amp; pat[i] != pat[len]) &#123; if (len) len = next[len - 1]; else next[i++] = 0; &#125; &#125;&#125;int kmp(char *txt, char *pat) &#123; int m = strlen(txt); int n = strlen(pat); int *next = (int *)malloc(sizeof(int)*n); CalcNext(pat, next); int i = 0, j = 0; while (i &lt; m) &#123; if (txt[i] == pat[j]) &#123; i++; j++; &#125; if (j == n) return i - j; if (j &lt; m &amp;&amp; txt[i] != pat[j]) &#123; if (j) j = next[j - 1]; else i++; &#125; &#125; return -1;&#125;int main() &#123; char *txt = \"BBC ABCDAB ABCDABCDABDE\"; char *pat = \"ABCDABD\"; printf(\"%d\", kmp(txt, pat)); return 0;&#125;","link":"/2016-10-11-kmp-algo/"},{"title":"神经网络与反向传播算法","text":"神经网络学习 神经网络神经网络中最基本的成分是神经元(neuron)模型。在生物神经网络中，每个神经元与其他神经元相连，当它“兴奋”时，就会向相连的神经元发送化学物质，从而改变这些神经元内的点位；如果某神经元的点位超过了一个“阈值”(threshold)，那么它就会被激活，即“兴奋”起来，向其他神经元发送化学物质。 M-P神经元模型神经元接收到来自$n$个其他神经元传递过来的输入信号$x_i$，这些输入信号通过带权重$w_i$的连接进行传递，神经元接收到的总输入值将与神经元的阈值进行比较，然后通过激活函数处理以产生神经元的输出。 $$y = f(\\sum_{i=1}^nw_ix_i - θ)$$ 激活函数阶跃函数 $$f(x) = \\begin{cases} 1, &amp; x \\geq 0 \\\\0, &amp; x &lt; 0 \\\\\\end{cases} $$单极性sigmoid函数$$f(x) = \\frac{1}{1+e^{-x}}$$双极性sigmoid函数$$f(x) = tanh(x) = \\frac{1 - e^{-x}}{1+e^{-x}}$$ 感知机与多层网络感知机(Perceptron)由两层神经元组成，输入层接收外部输入信号后传递给输出层，输出层是M-P神经元。感知机能容易地实现逻辑与、或、非运算。感知机的输出$y=f(\\sum_{i}w_ix_i-θ)$，假定$f$是阶跃函数，有 与运算$(x_1∩x_2)$:令$w_1=w_2=1,θ=2$,则$y=f(1\\cdot x_1+1\\cdot x_2-2)$,仅在$x_1=x_2=1$时，$y=1$; 或运算$(x_1∪x_2)$:令$w_1=w_2=1,θ=0.5$,则$y=f(1\\cdot x_1+1\\cdot x_2-0.5)$,当$x_1=1$或$x_2=1$时，$y=1$; 非运算$(┐x_1)$:令$w_1=-0.6,w_2=0,θ=-0.5$,则$y=f(-0.6\\cdot x_1+0\\cdot x_2+0.5)$,当$x_1=1$时，$y=0$;当$x_1=0$时，$y=1$. 当给定训练数据集，权重$w_i(i=1,2,….,n)$以及阈值$θ$可以通过学习得到。对于训练样例$(\\textbf{x},y)$,若当前感知机的输出为$\\hat{y}$,则感知机权重的调整为:$$w_i←w_i+Δw_i$$ $$Δw_i=\\eta(y-\\hat{y})x_i$$其中$\\eta\\in(0,1)$称为学习率(learning rate).要解决非线性可分问题，需要考虑使用多层功能神经元。输出层与输入层之间的一层神经元，被称为隐层或隐含层(hidden layer),隐含层和输出层神经元都是拥有激活函数的功能神经元。 误差逆传播算法多层网络的学习能力比单层感知机强很多，要训练多层网络，需要更强大的学习算法。误差逆传播（error BackPropagation,简称BP）算法就是典型。现实任务中使用神经网络时，大多是在使用BP算法进行训练。给定训练集$D={(x_1,y_1),(x_2,y_2),…,(x_m,y_m)},x_i∈R^d,y_i∈R^l$,即输入实例由d各属性描述，输出l维实值向量。","link":"/2017-06-15-neural-net/"},{"title":"socks5协议","text":"socks5协议简介socks5协议比较简单，rfc1928 只有9页。socks5协议是常见的代理协议之一，几乎所有浏览器都支持socks5协议。 握手阶段客户端与服务器在握手阶段协商认证方式，如采用用户名/密码方式，或者不采用认证方式。客户端发送的消息结构如下（数字表示占用字节数）12345+----+----------+----------+|VER | NMETHODS | METHODS |+----+----------+----------+| 1 | 1 | 1~255 |+----+----------+----------+ VER表示当前协议版本号，也就是5 NMETHODS表示METHODS字段占用的字节数 METHODS表示客户端支持的所有认证方式，每一个字节表示一种认证方式 服务器收到客户端的协商请求后，会检查服务器支持的认证方式，并回复客户端消息12345+----+--------+|VER | METHOD |+----+--------+| 1 | 1 |+----+--------+ 无认证的协商握手阶段流程举例12client -&gt; server: 0x05 0x01 0x00server -&gt; client: 0x05 0x00 建立连接握手完成后，客户端会向服务器发起请求12345+----+-----+-------+------+----------+----------+|VER | CMD | RSV | ATYP | DST.ADDR | DST.PORT |+----+-----+-------+------+----------+----------+| 1 | 1 | 1 | 1 | Variable | 2 |+----+-----+-------+------+----------+----------+ CMD: 是command的缩写 0x01: 表示建立TCP连接 0x03: 关联UDP请求 RSV: 保留字段，值为0x00 ATYP: 表示address type，取值 0x01: IPv4 0x03: 域名 0x04: IPv6 DST.ADDR :destination address 的缩写，取值随 ATYP 变化： ATYP == 0x01：4 个字节的 IPv4 地址 ATYP == 0x03：1 个字节表示域名长度，紧随其后的是对应的域名 ATYP == 0x04：16 个字节的 IPv6 地址 DST.PORT 字段：目的服务器的端口。 收到客户端请求后，服务器回应消息12345+----+-----+-------+------+----------+----------+|VER | REP | RSV | ATYP | BND.ADDR | BND.PORT |+----+-----+-------+------+----------+----------+| 1 | 1 | 1 | 1 | Variable | 2 |+----+-----+-------+------+----------+----------+ REP 字段：用以告知客户端请求处理情况。 其它字段和请求中字段的取值类型一样。 传输阶段socks5协议在完成握手和建立连接之后，就只做简单的转发。123client &lt;- 握手 -&gt; serverclient &lt;- 建立连接 -&gt; serverclient &lt;- 传输 -&gt; server &lt;- 传输 -&gt; destination","link":"/2017-08-06-sock5-proto/"},{"title":"x86_64汇编","text":"x86_64汇编简析 AT&amp;T与Intel汇编代码格式在unix与linux系统中，更多采用了AT&amp;T格式的汇编。两者区别： AT&amp;T格式汇编，寄存器名要加上’%’作为前缀；而Intel汇编不需要。 AT&amp;T格式 Intel格式 pushl %eax push eax 在AT&amp;T格式汇编中，用’$’前缀表示一个立即操作数；而在Intel格式中，不需要加前缀。 AT&amp;T格式 Intel格式 pushl $1 push 1 AT&amp;T 和 Intel 格式中的源操作数和目标操作数的位置正好相反。在 Intel 汇编格式中，目标操作数在源操作数的左边；而在 AT&amp;T 汇编格式中，目标操作数在源操作数的右边。例如： AT&amp;T 格式 Intel格式 addl $1, %eax add eax, 1 在 AT&amp;T 汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀’b’、’w’、’l’分别表示操作数为字节（byte，8 比特）、字（word，16 比特）和长字（long，32比特）；而在 Intel 汇编格式中，操作数的字长是用 “byte ptr” 和 “word ptr” 等前缀来表示的。例如： AT&amp;T 格式 Intel格式 movb val, %al mov al, byte ptr val 在 AT&amp;T 汇编格式中，内存操作数的寻址方式是section:disp(base, index, scale)而在 Intel 汇编格式中，内存操作数的寻址方式为：section:[base + index*scale + disp]由于 Linux 工作在保护模式下，用的是 32 位线性地址，所以在计算地址时不用考虑段基址和偏移量，而是采用如下的地址计算方法：disp + base + index * scale AT&amp;T 格式 Intel格式 movl -4(%ebp), %eax mov eax, [ebp - 4] movl array(, %eax, 4), %eax mov eax, [eax*4 + array] movw array(%ebx, %eax, 4), %cx mov cx, [ebx + 4*eax + array] movb $4, %fs:(%eax) mov fs:eax, 4 寄存器X84中原有8个32位通用寄存器%eax，%ebx，%ecx，%edx，%esi，%edi，%ebp，%esp, 在X86_64中分别被扩展为64位，并且多了8个寄存器。因此X86_64的寄存器如下： rax, eax, ax, ah, al; rbx, ebx, bx, bh, bl; rcx, ecx, cx, ch, cl; rdx, edx, dx, dh, dl; rsi, esi, si; rdi, edi, di; rbp, ebp; rsp, esp; r8-r15; GCC中对这些寄存器的调用规则如下： %rax 作为函数返回值使用。 %rsp 栈指针寄存器，指向栈顶 %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。 %rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改 %r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值 栈桢结构与函数调用C语言属于面向过程语言，他最大特点就是把一个程序分解成若干过程（函数），比如：入口函数是main，然后调用各个子函数。在对应机器语言中，GCC把过程转化成栈帧（frame），简单的说，每个栈帧对应一个过程。X86-32典型栈帧结构中，由%ebp指向栈帧开始，%esp指向栈顶。 举个例子:123456789101112131415161718192021222324#include &lt;stdio.h&gt;int foo(int i, int j)&#123; int a = i + j; int b = 2; printf(\"sum=%d\\n\", a+b); return (a+b);&#125;void bar()&#123; int a = 1; int b = 2; foo(a, b);&#125;int main()&#123; int a = 5; int b = 6; bar(); return 0;&#125; main:12345678910111213141516171819202122public _main_main proc nearvar_C= dword ptr -0Chvar_8= dword ptr -8var_4= dword ptr -4push rbpmov rbp, rspsub rsp, 10hmov [rbp+var_4], 0mov [rbp+var_8], 5mov [rbp+var_C], 6call _barxor eax, eaxadd rsp, 10hpop rbpretn_main endp__text ends foo:1234567891011121314151617181920212223242526272829303132public _foo_foo proc nearvar_14= dword ptr -14hvar_10= dword ptr -10hvar_C= dword ptr -0Chvar_8= dword ptr -8var_4= dword ptr -4push rbpmov rbp, rspsub rsp, 20hlea rax, aSumD ; \"sum=%d\\n\"mov [rbp+var_4], edimov [rbp+var_8], esimov esi, [rbp+var_4]add esi, [rbp+var_8]mov [rbp+var_C], esimov [rbp+var_10], 2mov esi, [rbp+var_C]add esi, [rbp+var_10]mov rdi, rax ; char *mov al, 0call _printfmov esi, [rbp+var_C]add esi, [rbp+var_10]mov [rbp+var_14], eaxmov eax, esiadd rsp, 20hpop rbpretn_foo endp bar:1234567891011121314151617181920public _bar_bar proc nearvar_C= dword ptr -0Chvar_8= dword ptr -8var_4= dword ptr -4push rbpmov rbp, rspsub rsp, 10hmov [rbp+var_4], 1mov [rbp+var_8], 2mov edi, [rbp+var_4]mov esi, [rbp+var_8]call _foomov [rbp+var_C], eaxadd rsp, 10hpop rbpretn_bar endp","link":"/2017-09-21-x86-assembly/"},{"title":"linux内核使用的数据结构","text":"linux内核中使用的数据结构详解 链表经典的单链表实现，节点结构体中是一个数据域和一个指针域。数据域保存着数据，指针域指向链表的下一个元素。链表相对于数组，链表的节点是可以动态创建并插入，在内存中无须占用连续的内存区域。为了实现不连续的存放，需要指针域将各个节点联系在一起。1234typedef struct node&#123; void *data; struct node *next;&#125;node; 链表的插入与删除操作单向链表节点的插入操作，需要找到插入的位置，调整前一个节点和插入节点的指针域即可。删除操作，调整前一个节点的指针域即可。 单向链表有一些缺点，如当已知指向某节点的指针，需要删除该节点时，需要平均O(n)的复杂度来寻找到需要删除节点的前一个节点，再调整指针域进行删除。这时可以增加一个前向的指针域，实现双向链表来解决。 双向链表12345typedef struct dnode&#123; void *data; struct dnode *prev; struct dnode *next;&#125;dnode; 双向循环链表当我们需要获取到链表尾部节点时，需要遍历整个链表，直至最后一个节点。双向循环链表通过增加一个头节点，将链表的头尾连接起来，形成循环链表，这样更方便获取尾部节点或者从尾到头遍历。 linux内核中链表的实现c语言实现的经典链表实现会带来什么问题？当前有两个结构foo和bar,都是以双向链表形式将各个结构体连接的，结构体中增加了prev和next指针。这就带来了一个问题，当需要插入、删除、遍历foo或者bar的链表时，需要定义两套list_insert、list_delete与list_foreach操作。1234567891011121314151617typedef struct foo &#123; int foo_length; int foo_value; struct foo *prev; struct foo *next;&#125;foo;typedef struct bar &#123; int bar_count; int bar_value; bool is_bar_ready; struct bar *prev; struct bar *next;&#125;bar;void list_foo_insert(foo *head, foo *insert_node);void list_bar_insert(bar *head, bar *insert_node); linux内核实现的方式是将链表节点指针域拼装成结构体，再嵌入其他数据结构中。12345678910struct list_head &#123; struct list_head *prev; struct list_head *next;&#125;;typedef struct foo &#123; int foo_length; int foo_value; struct list_head list;&#125;foo; 当需要链表相关操作的函数时，传入的参数就不需要是foo或者bar这样具体的数据结构，而是list_head指针。123#define LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;#define LIST_HEAD(name) \\ struct list_head name = LIST_HEAD_INIT(name) 12345678910static inline void list_add(struct list_head *new, struct list_head *head)&#123; __list_add(new, head, head-&gt;next); //具体实现include/linux/list.h&#125;static LIST_HEAD(head);foo foo1, foo2;//foo1 and foo2 do something, then add to headlist_add(&amp;head, &amp;foo2-&gt;list);list_add(&amp;head, &amp;foo1-&gt;list); 这样就将head、foo1、foo2通过list_head关联起来。如果已知head，那么我们可以获取到foo1和foo2中的list_head。如何通过list_head获取到foo1和foo2？linux内核中使用list_entry。12345678#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)#define container_of(ptr, type, member) (&#123; \\ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );&#125;)#define list_entry(ptr, type, member) \\ container_of(ptr, type, member) list_entry第一个参数为指向list_head的指针，第二个参数为宿主结构体的类型，第三个参数为该list_head结构在宿主结构体中的成员名。重新对链表节点的结构进行命名，举例说明如何获取到指向宿主结构体的指针。123456789101112typedef struct dnode &#123; struct dnode *prev; struct dnode *next;&#125;dnode;typedef struct foo &#123; nt foo_length; int foo_value; dnode node;&#125;foo;//通过链表查找或遍历，获取到指向foo结构中node的指针pnode，此时要获取宿主结构体的指针，用list_entryfoo *pfoo = list_entry(pnode, foo, node); 分析一下list_entry是如何获取到宿主结构体指针的。container_of通过结构体成员的指针，获取到宿主结构体的指针。该宏最后返回的是(type *)类型，是用结构体中成员的指针减去该成员在结构体中的偏移。 哈希linux内核的哈希实现处理冲突是开链法。初始化时设置固定的哈希桶个数，哈希桶中的每个元素保存的是双向链表的头结点。通过哈希函数，将元素分配到桶中，插入链表，元素冲突时链表会增长。由于哈希的冲突链只是保存冲突的元素，因此选用双向链表。linux内核中哈希冲突链使用的双向链表，头结点是hlist_head,节点是hlist_node。hlist_head中只保存了链表的首个元素的地址，节点hlist_node中，前向节点指针是二级指针，后面我们再分析为什么使二级指针。定义一个哈希表时，使用DEFINE_HASHTABLE,可以看到定义了一个固定大小的hlist_head数组，并初始化所有的元素。1234567891011#define DEFINE_HASHTABLE(name, bits) \\ struct hlist_head name[1 &lt;&lt; (bits)] = \\ &#123; [0 ... ((1 &lt;&lt; (bits)) - 1)] = HLIST_HEAD_INIT &#125;struct hlist_head &#123; struct hlist_node *first;&#125;;struct hlist_node &#123; struct hlist_node *next, **pprev;&#125;; 举个例子，bits=2,hashsize=4,hashtable数组有四个hlist_head元素。现在需要将key为d和h的元素存入哈希表中。使用简单的哈希函数pos(x)=x % hashsize，使用字符的ascii码。key为d需要存入哈希表的0位置，h也需要存入0位置。d和h被串联在0位置的链表中。linux内核使用hlist_head与hlist_node来组成哈希表，而不使用list_head。首先，使用hlist_head哈希的冲突链头结点不需要一个前向指针，可以节省一个指针的大小，对于一个较大的哈希表能节省很多空间。hlist_node中的前向指针使用二级指针，为了保持添加元素时的一致性。如果前向指针不使用二级指针，哈希冲突链的第一个hlist_node结点的向前指针应该是hlist_head *,不是第一个结点，前向指针是hlist_node *，这就会导致链表操作函数实现变得复杂。如果使用二级指针hlist_node **，就不会有前一个节点是头结点或非头结点，类型不一致的复杂情况。从linux内核中的hlist_add_before可以看出，将新的节点插入第一个hlist_node结点的前面，和不是第一个hlist_node结点的前面，实现是一致的。123456789101112131415161718static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)&#123; struct hlist_node *first = h-&gt;first; n-&gt;next = first; if (first) first-&gt;pprev = &amp;n-&gt;next; WRITE_ONCE(h-&gt;first, n); n-&gt;pprev = &amp;h-&gt;first;&#125;/* next must be != NULL */static inline void hlist_add_before(struct hlist_node *n, struct hlist_node *next)&#123; n-&gt;pprev = next-&gt;pprev; n-&gt;next = next; next-&gt;pprev = &amp;n-&gt;next; WRITE_ONCE(*(n-&gt;pprev), n);&#125;","link":"/2017-10-29-linux-data_struct/"},{"title":"红黑树的插入与删除","text":"详解红黑树的插入与删除红黑树的性质:123451.节点是红色或黑色2.根是黑色3.所有叶子都是黑色（叶子是NIL节点）4.从每个叶子到根的所有路径上不能有两个连续的红色节点 *5.从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点 * 这是一颗红黑树： 查找红黑树也是二叉查找树，因此查找操作与普通二叉查找树操作相同。红黑树插入和删除操作会导致不再匹配红黑树性质，需要进行颜色变更和旋转调整红黑树，使其恢复性质。 插入1234561）如果是空树则插入根节点并标黑，结束2）树不为空，插入节点后标红 a）如果插入节点的父节点是黑色，结束 b）插入节点的父节点是红色（违反性质4） 1.叔父节点是黑色或NIL，旋转操作，重新着色，结束 2.叔父节点是红色，将父节点和叔父节点染黑，祖父节点染红，并重新检查 我们分析当插入节点N后，父节点为红色时的情况。（违背红黑树性质4） 1.叔父节点是红色。将父节点和叔父节点染黑，祖父节点染红，从祖父节点检查是否违背性质4，递归进行 1) 2) 2.叔父节点是黑色（或NIL），插入节点是其父节点的右儿子。对P、N进行左旋操作。进行3) 3.叔父节点是黑色（或NIL），插入节点是其父节点的左儿子。对G、P进行右旋操作，P、G颜色对换。 删除12341）如果要删除的节点有两个非空儿子，可以转换成有0个或1个非空子节点2）如果删除节点是红色，则删除(路径上黑色节点数不变，不影响红黑树性质)3）如果删除节点是黑色带红色子节点，则删黑色节点，子节点替代被删节点并染黑4）如果删除节点是黑色并且儿子节点为黑色--&gt;复杂情况 1) 2) 3)的操作较简单。 对于情况4），将节点删除后用黑色子节点替换，此时如果要保持路径上黑节点数不变，可以认为该节点带有双重黑色的性质，称为双黑。 (假设图中1 2 3 4 5 6节点为NIL，删除N节点后用NIL替换，并带有双重黑色) 下面讨论情况4）的N节点删除： 1.当兄弟节点S为红色。对P、S节点进行左旋，对换颜色。此时尚未完成，后续需要继续调整3 4 5。 2.N的父亲、兄弟和侄子都是黑色。这种情况需要将兄弟节点S染红，P变为双重黑色节点，向上传递。 3.N的父节点为红色，兄弟节点及侄子节点都为黑色。这种情况需要交换P和S的颜色，并不影响不通过N的路径上黑色节点的数量，但在N的路径上增加了一个黑色节点，补充了被删除的黑色节点，此时N的双重黑色可以去掉。 4.兄弟节点是黑色，近侄节点为红，远侄节点为黑。这种情况对SL和S做右旋转，交换颜色。此时所有路径黑色节点数不变，后续情形5. 5.兄弟节点为黑色，远侄节点为红色。这种情况下对P、S进行左旋转，交换颜色，并染黑S右节点（旋转前的远侄节点）","link":"/2017-11-12-red-black-tree/"},{"title":"异或链表","text":"发现了一个奇技淫巧，一个指针域实现双向链表。xor linked list 异或链表（英语：XOR linked list）是数据结构里面的一种链式存储结构,可以在降低空间复杂度的情况下达到和双向链表一样的目的，使得在任何一个结点都能方便地访问它的前驱结点和后继结点。 概述普通双向链表的每个结点有三个域 ，分别存储着前一个结点的地址、后一个点的地址，以及数据 … A——–&gt;B———–&gt;C———-&gt;D——–&gt;E …&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–&gt; next –&gt; next –&gt; next –&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;– prev &lt;– prev &lt;– prev &lt;–异或链表通过异或操作（这里用⊕表示）把前一个结点的地址和后一个结点的地址变成一个地址 … A———–&gt;B———–&gt;C————&gt;D———–&gt;E …&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;–&gt; A⊕C B⊕D C⊕E link(B) = addr(A)⊕addr(C), link(C) = addr(B)⊕addr(D), … 当从左往右遍历的时候，如果当前结点是C，指针域是内容是B⊕D,通过和前一个结点B的地址做异或操作就能得到下一个结点D的地址，如此重复便能遍历整个链表。","link":"/xor-list/"},{"title":"linux内核设计与实现","text":"linux内核设计与实现 进程进程就是处于执行期的程序（目标码存放在其某种存储介质上）但进程并不仅仅局限于一段可执行程序代码（Unix称其为代码段，text section）。通常进程还要包含其他资源，像打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程（thread of execution）。 执行线程（thread），是在进程中活动的对象。每个线程都拥有一个独立的程序计数器，进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。对linux而言，线程是一种特殊的进程。 进程描述符及任务结构内核把进程的列表存放在任务队列（task list）的双向循环链表中。链表中每一项都是类型为task_struct、成为进程描述符（process descriptor）的结构，该结构定义在&lt;linux/sched.h&gt;。 分配进程描述符linux通过slab分配器分配task_struct结构，这样可以达到对象复用和缓存着色（cache coloring）。 123456789101112struct thread_info &#123; struct task_struct *task; struct exec_domain *exec_domain; __u32 flags; __u32 status; __u32 cpu; int preempt_count; mm_segmemt_t addr_limit; struct restart_block restart_block; void *sysenter_return; int uaccess_err;&#125;; 进程内核栈 进程状态 TASK_RUNNING（运行） TASK_INTERRUPTIBLE（可中断） TASK_UNINTERRUPTIBLE（不可中断） __TASK_TRACED 被其他进程跟踪的进程。 __TASK_STOPPED（停止） 进程上下文可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行。挡一个程序执行了系统调用或出发了某个异常，它就陷入了内核空间。此时，我们称内核“代表进程执行”并处于进程上下文中。在此上下文中current宏是有效的。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则内核退出时，程序回复在用户空间会继续执行。 线程实现从linux内核角度，没有线程的概念。linux把所有的线程都当做进程来实现。线程仅仅被视为一个与其他进程共享某些资源的进程。每个线程都拥有唯一隶属于自己的task_struct，所以在内核中，它看起来就像是一个普通的进程（只是线程和其他一些进程共享某些资源，如地址空间）。 创建线程线程的创建和普通进程的创建类似，只不过在调用clone()的时候需要传递一些参数标志来指明需要共享的资源： clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0); 上面的代码产生的结果和fork()差不多，只是父子俩共享地址空间、文件系统资源、文件描述符和信号处理程序。 普通的fork()实现是： clone(SIGCHLD, 0); 而vfork()的实现是： clone(CLONE_VFORK | CLONE_VM | SIGCHLD, 0); 内核线程内核线程（kernel thread）。内核线程和普通的进程间的区别在于内核线程没有独立的地址空间（实际上指向地址空间的mm指针被设置为NULL）。他们只在内核空间运行，不切换到用户空间。可以被调度，也可以被抢占。 进程终结进程调用exit()系统调用。—&gt;do_exit() 将task_struct标志成员置PF_EXITING 调用del_timer_sync() 如果进程记账开启，do_exit()会调用acct_update_integrals()输出记账信息 调用exit_mm()释放进程占用的mm_struct 调用sem__exit()。如果进程排队等待IPC信号，它则离开队列。 调用exit_files() 、exit_fs()分别递减文件描述符、文件系统数据的引用计数。 将task_struct的exit_code置为exit()提供的退出码 调用exit_notify()向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或者为init进程，并把进程状态（task_struct中exit_state）设置成EXIT_ZOMBIE do_exit()调用schedule()切换到新的进程 至此，进程相关的资源被释放掉，并处于EXIT_ZOMBIE状态。所占用的所有内存就是内核栈、thread_info和task_struct结构。存在的唯一目的就是向它的父进程提供信息。父进程检索到信息后，或者通知内核那是无关信息后，由进程所持有的剩余内存被释放，归还给系统使用。 删除进程描述符在调用do_exit()之后，尽管线程已经僵死不能再运行，但系统保留了它的进程描述符，可以让系统有办法在子进程中介后仍能获取信息。因此，进程终结时所需的清理工作和进程描述符的删除被分开执行。在父进程获得以终结的子进程信息后，或者内核通知并不关注信息后，子进程的task_struct结构才被释放。 wait()一族函数都是通过系统调用wait4()来实现的。挂起调用他的进程，直到其中一个子进程退出，此时函数会返回该子进程的PID。此外，调用该函数时提供的指针会包含子函数退出时的退出代码。 当最终需要释放进程描述符时，release_task()会被调用： 它调用_exit_signal()，该函数调用_unhash_process()，后者又调用detach_pid()从pidhash上删除该进程，同时也要从任务列表中删除该进程。 _exit_signal()释放目前僵死进程所使用的所有剩余资源并最终统计记录。 如果这个进程是线程组最后一个进程，并且领头进程已经死掉，那么release_task()就通知僵死的领头进程的父进程。 release_task()调用put_task_struct()释放进程内核栈和thread_info结构所占的页，并释放task_struct所占的slab告诉缓存。 进程调度多任务非抢占式多任务（cooperative multitasking）、抢占式多任务（preemptive multitasking）。 抢占（preemption） 进程的时间片（timeslice） 进程主动挂起自己：让步（yielding） 进程的优先级nice值，范围是从-20~+19，默认值为0；越大的nice值意味着更低的优先级。 公平调度完全公平调度（CFS）：进程调度的效果应如同系统具备一个理想的完美多任务处理器。在这种系统中，每个进程将能获得1/n的处理器时间 — n是指可运行进程的数量。 允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行的进程。 时间记账 进程选择 调度器入口 睡眠和唤醒 时间记账系统分配一个时间片给每一个进程。每次系统时钟节拍发生时，时间片就会减少一个节拍周期。当一个进程的时间片被减少到0时，它就会被另一个尚未减到0的时间片可运行进程抢占。 调度器实体结构&lt;linux/sched.h&gt; 123456789101112131415161718struct sched_entity &#123; /* For load-balancing: */ struct load_weight load; unsigned long runnable_weight; struct rb_node run_node; struct list_head group_node; unsigned int on_rq; u64 exec_start; u64 sum_exec_runtime; u64 vruntime; u64 prev_sum_exec_runtime; u64 nr_migrations; struct sched_statistics statistics; ......&#125;; 调度器实体结构作为一个名为se的成员变量，嵌入进程描述符struct task_struct内。 虚拟实时 vruntime变量存放进程的虚拟运行时间（ns）。 cfs_rq（cfs的run queue）中的每一个进程都有一个虚拟时钟记录，vruntime。如果一个进程得以执行，随着时间的增长（也就是系统时钟一个个tick的到来），其vruntime将不断增大。没有得到执行的进程vruntime不变。 调度器总是选择vruntime跑得最慢的那个进程来执行。为了区别优先级，优先级高的进程vruntime增长的慢。 分配给进程的运行时间=调度周期*进程权重/所有进程权重之和 调度周期：将所有处于TASK_RUNNING的进程都调度一遍的时间。 举例：进程A、B，权重为1、2，调度周期为30ms，分配给A的CPU时间为：30ms*(1/(1+2))=10ms vruntime=实际运行时间*NICE_0_LOAD/进程权重 进程选择CFS使用红黑树来组织可运行进程队列，并利用其迅速找到最小vruntime值得进程。（红黑树最左侧的节点） 新进程vruntime的选择：每个CPU的运行队列cfs_rq都维护一个min_vruntime，记录该队列中所有进程的vruntime最小值，新进程的初始vruntime值以此队列中的min_vruntime为基础设置。 sched_child_runs_first:规定fork之后让子进程先于父进程运行； sched_features的START_DEBIT位：规定新进程的第一次运行要有延迟。 子进程在创建时，vruntime初值为min_vruntime；然后如果sched_features中设置了START_DEBIT位，vruntime会在min_vruntime的基础上增大一些。设置完子进程的vruntime后，检查sched_child_runs_first参数，如果为1，就比较父进程和子进程的vruntime，如果父进程的vruntime小，就对换父子进程的vruntime，保证子进程先于父进程运行。 调度器入口schedule() 睡眠与唤醒系统调用内核提供了用户进程与内核进行交互的一组接口。（Linux中常称为syscall） 通知内核的机制是靠软中断实现的：通过引发一个异常来促使系统切换到内核态去执行异常处理程序。x86系统上预定义的软中断时中断号128，通过int 0x80指令触发该中断，系统切换到内核态并执行第128号异常处理程序，这个处理程序叫syscall()。 copy_to_user() copy_from_user() 系统调用上下文内核在执行系统调用的时候处于进程上下文。current指针指向当前任务，即引发系统调用的那个进程。 内存管理页内核把物理页作为内存管理的基本单元。内存管理单元(MMU)通常以页为单位进行处理。从虚拟内存角度来看，页是最小单位。 1234567891011struct page &#123; unsigned long flags; //页的状态，是否为脏，是否锁定。 atomic_t _count; //页的引用计数。 atomic_t _mapcount; unsigned long private; struct address_space *mapping; pgoff_t index; struct list_head lru; void *virtual; //页的虚拟地址。 ...&#125;; 区 ZONE_DMA ZONE_DMA32 ZONE_NORMAL ZONE_HIGHMEM slab层虚拟文件系统虚拟文件系统（VFS），作为内核子系统，为用户空间提供了文件和文件系统相关的接口。 目录模型 VFS层次VFS（Virtual Filesystem Switch） VFS的概念VFS中有四个主要对象类型： superblock：代表一个具体的已安装文件系统 inode：代表一个具体的文件（VFS中有inode概念，文件系统中也有inode概念） dentry：代表一个目录项，文件目录中的一个点，可以是目录也可以是文件 file object：代表由进程打开的文件 VFS将目录作为一个文件来处理，所以不存在目录对象。目录项不同于目录，但目录是另一种形式的文件。 superblock超级块对象：各文件系统都必须实现超级块对象，用于存储特定文件系统的信息，对应于存放在磁盘特定扇区中的文件系统超级块获文件系统控制块。 inode索引节点对象：包含了内核在操作文件或目录时需要的全部信息。（除文件名） 文件的字节数 文件拥有者的User ID 文件的Group ID 文件的读、写、执行权限 文件的时间戳，共有三个： ctime指inode上一次变动的时间 mtime指文件内容上一次变动的时间 atime指文件上一次打开的时间 链接数，即有多少文件名指向这个inode 文件数据block的位置 12stat file.txtls -i file.txt dentry目录项对象：所包含文件的文件名，以及该文件名对应的inode号。 目录文件的读权限（r）和写权限（w），都是针对目录文件本身。目录文件内只有文件名和inode号，所以只有读权限（r），只能获取文件名，无法获取其他信息，因为其他信息存储在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。 硬链接与软链接硬链接实际上是dentry项的一个拷贝，它们都指向同一个inode节点。inode链接数记录了hard link指向的计数。新增一个硬链接，会增加inode信息中的链接数，删除一个硬链接，则减少。在创建目录时，会生成当前目录和父目录”.” “..”。前者的inode号码就是当前目录的inode号码，后者为父目录的inode号码。 ln 源文件 目标文件 软链接（symbolic link）类似于windows中的快捷方式。软链接与源文件inode号不一样，但是软链接中的内容是源文件的路径。读取软链接时，系统会自动导向源文件。 ln -S 源文件 目标文件 进程对文件的管理进程描述符task_struct中有两个与文件相关的变量：fs与files。 1234567891011121314151617181920212223242526272829303132333435 /* Filesystem information: */ struct fs_struct *fs; /* Open file information: */ struct files_struct *files;struct fs_struct &#123; int users; //用户数目 spinlock_t lock; //保护该结构体的锁 seqcount_t seq; int umask; //掩码 int in_exec; //当前正在执行的文件 struct path root, pwd; //根目录路径、当前工作目录路径&#125; __randomize_layout;struct files_struct &#123; /* * read mostly part */ atomic_t count; bool resize_in_progress; wait_queue_head_t resize_wait; struct fdtable __rcu *fdt; struct fdtable fdtab; /* * written part on a separate cache line in SMP */ spinlock_t file_lock ____cacheline_aligned_in_smp; unsigned int next_fd; unsigned long close_on_exec_init[1]; unsigned long open_fds_init[1]; unsigned long full_fds_bits_init[1]; struct file __rcu * fd_array[NR_OPEN_DEFAULT];&#125;; files_struct结构体由进程描述符files指向。fd_array数组指针指向已打开的文件对象。如果一个进程所打开文件超过NR_OPEN_DEFAULT，内核将分配一个新数组，并将fdt指向它。 fs_struct由进程描述符中fs指向。 进程地址空间内存描述符mm_struct。 虚拟内存区域vm_area_struct (Virtual memory areas, VMAs)","link":"/2017-12-24-linux-kernel/"}],"tags":[{"name":"ML/DL","slug":"ML-DL","link":"/tags/ML-DL/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"read","slug":"read","link":"/tags/read/"},{"name":"c/c++","slug":"c-c","link":"/tags/c-c/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"openssl","slug":"openssl","link":"/tags/openssl/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"socket","slug":"socket","link":"/tags/socket/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"kmp","slug":"kmp","link":"/tags/kmp/"},{"name":"bp","slug":"bp","link":"/tags/bp/"},{"name":"sock5","slug":"sock5","link":"/tags/sock5/"},{"name":"assembly","slug":"assembly","link":"/tags/assembly/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"datastructure","slug":"datastructure","link":"/tags/datastructure/"}],"categories":[{"name":"learn","slug":"learn","link":"/categories/learn/"}]}